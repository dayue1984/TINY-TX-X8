/*
2017-8-14 : 为防止多个中断间相互影响，从影响发送时序问题。先只保留一个中断(包括除定时器外，其他中断)。定时器2 作为无线发送以及1mS时基来使用。
*/

#include "include.h"

volatile bool tbc_2ms_flag = false ; 						//注意 : 这个未必就是真正精确的 2mS 
static uint16_t TIM2_Cnt = 0 ; 
uint8_t TIM2_ErrorCnt = 0 ; 
////////////////////////////////////////////////////////////////////////////////
///                  TIM2:无线发送时基控制以及置位2mS标志位  	        ////////
////////////////////////////////////////////////////////////////////////////////
void tbc_init (void)
{
  	//打开外设 TIM3 TIM2 时钟
	CLK -> PCKENR1 |= (1<<1)|(1<<0);
	//无线发送
	TIM2 -> CR1  |= (1<<3);    						//中断后停止计数
	TIM2 -> PSCR  = 0x03 ;							//注意: TIM2的频率是 F = Fsc/(PSCR)=12M/8 = 1.5M
	TIM2 -> ARRH  = 0x05 ;							//定时2MS
	TIM2 -> ARRL  = 0xDC ;
	TIM2 -> IER  |= (1<<0);							//初始化 溢出中断
	TIM2 -> CR1  |= (1<<0);    						//开始计数
}


////////////////////////////////////////////////////////////////////////////////
/////				看门狗初始化				////////
////////////////////////////////////////////////////////////////////////////////
void WatchDog_Init(void)
{
	//看门狗初始化
  	IWDG -> KR  = 0xCC  ;    						// 使能看门狗
	IWDG -> KR  = 0x55 ; 							// 解锁看门狗寄存器
	IWDG -> PR  = 0x03 ; 							// Divider/64 =>  f = 38K/32= 1.1875kHz
	IWDG ->	RLR = 200  ;    						// T = 200 / 1.1875kHz ≈ 170mS
	IWDG -> KR  = 0xAA ; 							// 锁定看门狗寄存器
}

////////////////////////////////////////////////////////////////////////////////
/////			   CC2500数据发送中断				 ///////
/////	为严格保证发送间隔 ，故用定时中断来保证发送时序(中断等级最高)    ///////	
////////////////////////////////////////////////////////////////////////////////
void tbc_t2_Updatisr (void)
{	
	if(TIM2 -> SR1 & (1<<0))
	{
		TIM2 -> SR1 = ~(1<<0) ;
		tbc_2ms_flag = true;
		
		if(CommunicationError_flg == false) TIM2_Cnt = ReadFRSKYD16() ; 
		else  TIM2_Cnt = 0x0BB8 ; 
		
		//如果返回值为 0 , 说明发送故障(停止 发送 , 不再打开定时中断)
		if(TIM2_Cnt == 0)
		{
			CommunicationError_flg = true ; 
			if(TIM2_ErrorCnt < 250) ++TIM2_ErrorCnt ;
			Write_EE_Byte(TIM2_ErrorCnt , TIM2ErrorCnt_ADDR);
			while(1);
		}
		else
		{
			TIM2 -> ARRH  = TIM2_Cnt >> 8 ;				//定时1MS(每次中断，停止计数。防止发送间隔错位)
			TIM2 -> ARRL  = TIM2_Cnt & 0xFF ;
			TIM2 -> CR1  |= (1<<0);
		}
	}
}